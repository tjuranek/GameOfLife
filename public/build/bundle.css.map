{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../../Canvas.svelte",
    "../../Controls.svelte",
    "../../Heading.svelte",
    "../../Stats.svelte"
  ],
  "sourcesContent": [
    "<script>\n    import { onMount } from 'svelte'; \n    import { matrix } from \"../store.js\";\n\n    let canvas;\n    let context;\n\n    // this takes the matrix and spits it onto the canvas. cells are red if they're alive. #gobigred\n    const drawGridOnCanvas = (matrix) => {\n        context.fillStyle = 'black';\n        context.fillRect(0, 0, 330, 180);\n\n        context.fillStyle = 'red';\n\n        for (let x = 0; x < 330; x++) {\n            for (let y = 0; y < 180; y++) {\n                if (matrix[x][y].livesRemaining > 0) {\n                    context.fillRect(x, y, 1, 1);\n                }\n            }\n        }\n    }\n\n    // the canvas binding is undefined until the component mounts. \n    onMount(() => {\n        context = canvas.getContext('2d');\n        context.scale(3, 3);\n\n        // this subscribes to the matrix in store and runs drawOnCanvas every time it has a new value. gotta subscribe after the canvas context is defined though.\n        matrix.subscribe(updatedMatrix => {\n            drawGridOnCanvas(updatedMatrix);\n        });\n    });\n</script>\n\n<main>\n    <div class=\"container\">\n        <canvas bind:this={canvas} width=\"990\" height=\"540\"></canvas>\n    </div>\n</main>\n\n<style>\n    .container {\n        display: flex;\n        justify-content: center;\n    }\n</style>",
    "<script context=\"module\">\n    import { iterationCount, iterationInterval, matrix } from \"../store.js\";\n    import Gameboard from \"../models/gameboard.js\";\n\n    // create a gameboard\n    const gameboard = new Gameboard(180, 330);\n    gameboard.randomlyPopulate();\n\n    // set the initial gameboard matrix in store\n    matrix.set([...gameboard.matrix]);\n\n    // since we can pause/play, add a isRunning value that will get checked every render\n    let isRunning = false;\n\n    // set a default main loop interval\n    let mainInterval = 500;\n\n    // we show the interval in stats, so set it in state\n    iterationInterval.set(500);\n\n    // add a couple counters for determining if it's time to render a new iteration or not\n    let lastFrameTime = 0;\n    let lastRenderTime = 0;\n\n    // animation frame id, this is how we start or stop rendering\n    let requestId;\n\n    // the main game loop, it's always called by requestAnimationFrame which gives a timestamp which lets me have intervals.\n    const main = (time) => {\n        // big undefined boy for success in start/stop\n        requestId = undefined;\n\n        const timeSinceLastRender = time - lastRenderTime;\n\n        // if time since last render is past our interval render it up\n        if (timeSinceLastRender > mainInterval) {\n            lastRenderTime = time;\n\n            iterationCount.update(currentValue => currentValue + 1);\n\n            gameboard.iterate();\n\n            // after every interval update the store matrix, this will automatically draw in the canvas component because subscriptions. svelte is cool.\n            matrix.set([...gameboard.matrix]);\n        }\n\n        // if we are running, keep going, else stop\n        isRunning ? start() : stop();\n    } \n\n    // starts the loop up\n    const start = () => {\n        if (!requestId) {\n            requestId = requestAnimationFrame(main);\n        }\n    }\n\n    // stops the loop\n    const stop = () => {\n        if (requestId) {\n            cancelAnimationFrame(requestId);\n            requestId = undefined;\n        }\n    }\n\n    // toggle isRunning and go through game loop one time\n    const handlePausePlay = () => {\n        isRunning = !isRunning;\n\n        start();\n    }\n\n    // slows speed by increasing the interval, but never let the user be slower than 1 second\n    const handleSlowDown = () => {\n        if (mainInterval < 1000) mainInterval = mainInterval + 100;\n        iterationInterval.set(mainInterval);\n    }\n\n    // increase speed by decreasing interval, never going below a 0ms interval.\n    const handleSpeedUp = () => {\n        if (mainInterval > 0) mainInterval = mainInterval - 100;\n        iterationInterval.set(mainInterval);\n    }\n</script>\n\n<main>\n    <div class=\"container\">\n        <button on:click={handleSlowDown}>slower</button>\n        <button on:click={handlePausePlay}>pause/play</button>\n        <button on:click={handleSpeedUp}>faster</button>\n    </div>\n</main>\n\n<style>\n    .container {\n        display: flex;\n        justify-content: center;\n        padding-top: 1rem\n    }\n</style>",
    "<script></script>\n\n<main>\n    <div class=\"container\">\n        <h1>Cellular Automaton</h1>\n\n        <p>My simple version of cellular automaton inspired by John Conway's Game of Life. Created for a Nextek Development employee coding challenge.</p>\n    </div>\n</main>\n\n<style>\n    .container {\n        align-content: center;\n        display: flex;\n        flex-direction: column;\n        flex-wrap: wrap;\n        text-align: center;\n    }\n</style>",
    "<script>\n    import { iterationCount, iterationInterval } from \"../store.js\";\n</script>\n\n<main>\n    <div class=\"container\">\n        <p>Iteration Count: {$iterationCount}</p>\n        <p>Iteration Interval: {$iterationInterval} ms</p>\n    </div>\n</main>\n\n<style>\n    .container {\n        text-align: center;\n    }\n</style>"
  ],
  "names": [],
  "mappings": "AA0CI,UAAU,cAAC,CAAC,AACR,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,MAAM,AAC3B,CAAC;ACiDD,UAAU,cAAC,CAAC,AACR,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,MAAM,CACvB,WAAW,CAAE,IAAI;IACrB,CAAC;ACvFD,UAAU,cAAC,CAAC,AACR,aAAa,CAAE,MAAM,CACrB,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,SAAS,CAAE,IAAI,CACf,UAAU,CAAE,MAAM,AACtB,CAAC;ACLD,UAAU,cAAC,CAAC,AACR,UAAU,CAAE,MAAM,AACtB,CAAC"
}